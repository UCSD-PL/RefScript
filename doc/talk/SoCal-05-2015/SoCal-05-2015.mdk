[INCLUDE=presentation]
Title         : Trust, but Verify
Sub Title     : Two-Phase Typing for Dynamic Languages
Author        : **Panagiotis Vekris**` `Benjamin Cosman` `Ranjit Jhala
Affiliation   : University of California, San Diego
Reveal Theme  : solarized


[TITLE]


## Scripting Languages

Common task:
{ .mylist text-align=left }

Find the index of the smallest element in an array
{ .mylist font-style="italic" }


## First-order

```javascript { border-width=0px font-family="Droid Sans Mono" }
function minIndexFO (a) {
  if (a.length <= 0) return -1;
  var min = 0;
  for (var i = 0; i < a.length; i++) {
    if (a[i] < a[min]) 
      min = i;
  }
  return min;
}
```
\
<div class="fragment" align="left">
Directly manipulating array indices is error prone
</div>
\
<div class="fragment" align="left">
Fewer opportunities for abstraction
</div>


## Higher-order

```javascript { border-width=0px font-family="Droid Sans Mono" }
function $reduce(a, f, x) {
	var res = x, i;
	for (i = 0; i < a.length; i++)
      res = f(res, a[i], i);
	return res;
}
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
function minIndexHO(a) {
	if (a.length <= 0) return -1;
	var step = (min, cur, i) => cur < a[min] ? i : min;
	return $reduce(a, step, 0);
}
```
<div class="fragment"/>

Challenge for dataflow analyses:
{ .mylist text-align=left }

- Track relationships between values and closures

- `i` and `min` of `step` need to be valid indexers of `a` 


## Refinement Types

\+ Provide **precise specifications**
{ .mylist text-align=left }

```javascript { border-width=0px font-family="Droid Sans Mono" }
//@ type idx<x> = { v: number | 0 ≤ v && v < len (x) }
```

<div class="fragment"/>

```javascript { border-width=0px font-family="Droid Sans Mono" }
//@ $reduce :: <A,B>(a: A[], f: (B, A, idx<a>) => B, x: B) => B
function $reduce(a, f, x) {
  var res = x, i = 0;
  for (i = 0; i < a.length; i++) {
    res = f(res, a[i], i++);
  }
  return res;
}
```

<div class="fragment"/>

-- Require underlying **unrefined** static type system 
{ .mylist text-align=left }



## Problem: Value Based Overloading

*Syntactic entities may be bound to multiple types at run-time*

<div class="fragment"/>


```javascript { border-width=0px font-family="Droid Sans Mono" }
function reduce(a, f, x) {
  return (arguments.length === 3) ?
    $reduce(a, f, x) :
    $reduce(a, f, a[0]);
}
```
<div class="fragment"/>

```javascript { border-width=0px font-family="Droid Sans Mono" }
//@ reduce#1 :: <A,B>(a: A[], f: (B, A, idx<a>) => B, x: B) => B

//@ reduce#2 :: <A>(a: A[]+, f: (A, A, idx<a>) => A) => A
```

Behavior depends on **reflection** on variables (e.g. `arguments`)


## Solution: Two-phased Typing

* Split *basic types* and *refinement* reasoning into **two** phases 
that operate on distinct languages:

* **Source Language** (value-based overloading)
  - *Intersections*
  - *Untagged Unions*: different possible (run-time) types

* **Target language** (conventional ML-like language)
  - *Products*
  - *Tagged Unions*


## Example

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (number, number ) => number
            Λ (number, boolean) => boolean
 */
function negate(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```

`negate`'s behavior depends on value of `flag`



## Example

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (number, number ) => number
            Λ (number, boolean) => boolean
 */
function negate(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```


`negate`'s specification is problematic
{ .mylist text-align=left }

```javascript { border-width=0px font-family="Droid Sans Mono" }
var c = negate(0, 1);
var d = negate(1, true );
```

## Truthy / Falsy Values

```javascript { border-width=0px font-family="Droid Sans Mono" }
type tt = { v: number | v != 0}   // "truthy" numbers
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
type ff = { v: number | v  = 0}   // "falsy" numbers
```


## Example

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (tt, number ) => number
           /\ (ff, boolean) => boolean
 */
function negate(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```

Statically check the calls:
{ .mylist text-align=left }


```javascript { border-width=0px font-family="Droid Sans Mono" }
var a = negate(1, 1);       // OK
var b = negate(0, true );   // OK
var c = negate(0, 1);       // ERROR
var d = negate(1, true );   // ERROR
```


## 1st Phase (Trust)

-- Flow-, Path-, and Value-insensitive type-checking
{ .mylist text-align=left }
\
-- Wrap problematic expressions in DEAD-casts
{ .mylist text-align=left }


## 1st Phase (Trust) -- Clone

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#2(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```
```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#2 :: (ff, boolean) => boolean */
function negate#2(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```

## 1st Phase (Trust) -- Clone

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#2(flag, x) { ... }
```
```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#2 :: (ff, boolean) => boolean */
function negate#2(flag, x) { ... }
```

Overload resolution is based entirely on the *basic* type:
{ .mylist text-align=left }

```javascript { border-width=0px font-family="Droid Sans Mono" }
var a = negate#1(1, 1);
var b = negate#2(0, true);
var c = negate#1(0, 1);
var d = negate#2(1, true);
```

## 1st Phase (Trust) -- Clone

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#2(flag, x) { ... }
```
```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#2 :: (ff, boolean) => boolean */
function negate#2(flag, x) { ... }
```

Replace with conventional products and projections:
{ .mylist text-align=left }

```javascript { border-width=0px font-family="Droid Sans Mono" }
var negate = (negate#1, negate#2); 
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
var a = fst(negate)(1, 1);
var b = snd(negate)(0, true);
var c = fst(negate)(0, 1);
var d = snd(negate)(1, true);
```



## 1st Phase (Trust) -- Cast  { data-transition=fade }

Check each conjunct independently
{ .mylist text-align=left }

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#1(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;        // TYPE ERROR
}
```


## 1st Phase (Trust) -- Cast { data-transition=fade }

Add DEAD-cast for code that **should** be unreachable
{ .mylist text-align=left }


```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#1(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !DEAD(x);  // ADD CAST
}
```



## 2nd Phase (verify)

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#1(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !DEAD(x);
}
```

-- Performs standard refinement type-checking
{ .mylist text-align=left }


-- Flow and Path sensitive 
{ .mylist text-align=left }

-- DEAD-casts are regular calls
{ .mylist text-align=left }


```javascript { border-width=0px font-family="Droid Sans Mono" }
DEAD :: ∀ A, B . ({v: A | false}) => B
```


## 2nd Phase (Verify)

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#1(flag, x) {
  if (flag) {
    return 0 - x;
  }
  else {
    return !DEAD(x);          // A
  }
}
```
\
Subtyping obligation at point A:
$$
\Gamma_A \vdash \{ v: \texttt{number}\ |\ v = x \} 
\sqsubseteq \{ v: \texttt{number}\ |\ false \}
$$
Embed into logic:
$$
(\texttt{flag}!= 0 \wedge \texttt{flag} = 0) 
\Rightarrow
v = x
\Rightarrow
false   
$$


## Two-Phase Inference

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (number, number ) => number
           /\ (number, boolean) => boolean
 */
function negate(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```

Can we infer the refinements for `negate`? 



## Two-Phase Inference

0. Create a template and refine with a predicate variable:

\[
\begin{array}{ccl}
\texttt{negate} & :: & 
  (\{ v: \texttt{num}\ |\ k_1 \}, \{ v: \texttt{num}\ |\ k_2 \}) \Rightarrow \{ v: \texttt{num}\ |\ k_3 \} \\
       & \wedge &
  (\{ v: \texttt{num}\ |\ k_4 \}, \{ v: \texttt{bool}\ |\ k_5 \}) \Rightarrow \{ v: \texttt{bool}\ |\ k_6 \}         
\end{array}
\]

1. Trust Phase: like before


\[
\begin{array}{ccl}
\texttt{negate\#1} & :: & 
  (\{ v: \texttt{num}\ |\ k_1 \}, \{ v: \texttt{num}\ |\ k_2 \}) \Rightarrow \{ v: \texttt{num}\ |\ k_3 \} \\
  \vspace{2em}
\texttt{negate\#2} & :: & 
  (\{ v: \texttt{num}\ |\ k_4 \}, \{ v: \texttt{bool}\ |\ k_5 \}) \Rightarrow \{ v: \texttt{bool}\ |\ k_6 \}         
\end{array}
\]


## Two-Phase Inference

2. Verify
$$
\Gamma_A \vdash \{ v: \texttt{number}\ |\ v = x \}
\sqsubseteq 
\{ v: \texttt{number}\ |\ false \} 
$$
$$
(k_1\left[\texttt{flag}/v\right] 
\wedge 
\texttt{flag} = 0
)
\Rightarrow
v = x
\Rightarrow
false
$$

3. Solve via Liquid Types:

$$
k_1 \equiv (v = 0)
$$

## Extra material

To appear in ECOOP'15

![Screenshot from 2015-05-01 16:19:23]

[Screenshot from 2015-05-01 16:19:23]: images/Screenshot-from-2015-05-01-16-19-23.png "Screenshot from 2015-05-01 16:19:23" { width=auto max-width=90% }

Demo Available



<!-- 
## Formal Development

![Screenshot from 2015-04-30 08:29:12]

[Screenshot from 2015-04-30 08:29:12]: images/Screenshot-from-2015-04-30-08-29-12.png "Screenshot from 2015-04-30 08:29:12" { width=auto max-width=90% }

* Compile unrestricted intersections and unions

```{ border-width=0px font-family="Droid Sans Mono" }
% Int.+ ,, Real.+

val it : (int * int -> int) Λ (real * real -> real)
```

-->

## End