[INCLUDE=presentation]
Title         : Trust, but Verify
Sub Title     : Two-Phase Typing for Dynamic Languages
Author        : **Panagiotis Vekris**` `Benjamin Cosman` `Ranjit Jhala
Affiliation   : University of California, San Diego
Reveal Theme  : sky


[TITLE]


<!-- ## Contents -->

<!-- [TOC] -->


## Scripting Languages

> Find the minimum index of an array


## First-order

```javascript { border-width=0px font-family="Droid Sans Mono" }
function minIndexFO (a) {
  if (a.length <= 0) return -1;
  var min = 0;
  for (var i = 0; i < a.length; i++) {
    if (a[i] < a[min]) 
      min = i;
  }
  return min;
}
```

-- Directly manipulating array indices is error prone


## Higher-order

```javascript { border-width=0px font-family="Droid Sans Mono" }
function $reduce(a, f, x) {
  var res = x, i = 0;
  for (i = 0; i < a.length; i++)
    res = f(res, a[i], i++);
  return res;
}
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
function minIndexHO(a) {
  if (a.length <= 0) return -1;
  function step(min, cur, i) {
    return cur < a[min] ? i : min;
  }
  return $reduce(a, step, 0);
}
```

Harder for **dataflow analyses** to track *relationships* 
between values and closures:

-- Argument `i` of `step` is a valid indexer of array `a` 

## Refinement Types

\+ Provide **precise specifications**
{ .mylist text-align=left }

```javascript { border-width=0px font-family="Droid Sans Mono" }
//@ type idx<x> = { v: number | 0 ≤ v && v < len (x) }
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
//@ $reduce :: <A,B>(a: A[], f: (B, A, idx<a>) => B, x: B) => B

function $reduce(a, f, x) {
  var res = x, i = 0;
  for (i = 0; i < a.length; i++) {
    res = f(res, a[i], i++);
  }
  return res;
}
```

-- Require underlying **unrefined** static type system 
{ .mylist text-align=left }


## Problem: Value Based Overloading

*Syntactic entities may be bound to multiple types at run-time*

```javascript { border-width=0px font-family="Droid Sans Mono" }
function reduce(a, f, x) {
  return (arguments.length === 3) ?
    $reduce(a, f, x) :
    $reduce(a, f, a[0]);
}
```

Behavior depends on **reflection** on variables (e.g. `arguments`)

```javascript { border-width=0px font-family="Droid Sans Mono" }
//@ reduce#1 :: <A,B>(a: A[], f: (B, A, idx<a>) => B, x: B) => B
```
```javascript { border-width=0px font-family="Droid Sans Mono" }
//@ reduce#2 :: <A>(a: A[]+, f: (A, A, idx<a>) => A) => A
```

Circular dependency: Basic Types $\leftrightarrow$ Value reasoning


## Solution: Two-phased Typing

* Split *basic types* and *refinement* reasoning into **two** phases 
that operate on distinct languages:

* **Source Language** (value-based overloading)
  - *Intersections*
  - *Untagged Unions*: different possible (run-time) types

* **Target language** (conventional ML-like language)
  - *Products*
  - *Tagged Unions*


## Example

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (number, number ) => number
            Λ (number, boolean) => boolean
 */
function negate(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```

`negate`'s behavior depends on value of `flag`

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (number, number V boolean) => number V boolean */
```


## Example

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (number, number ) => number
            Λ (number, boolean) => boolean
 */
function negate(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```


`negate`'s specification is problematic

## Truthy / Falsy Values

```javascript { border-width=0px font-family="Droid Sans Mono" }
type tt = { v: number | v != 0}   // "truthy" numbers
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
type ff = { v: number | v  = 0}   // "falsy" numbers
```


## Example

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (tt, number ) => number
           /\ (ff, boolean) => boolean
 */
function negate(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
var a = negate(1, 1);       // OK
var b = negate(0, true );   // OK
var c = negate(0, 1);       // ERR
var d = negate(1, true );   // ERR
```


## 1st Phase (Trust)

-- Flow-, Path-, and Value-insensitive type-checking
{ .mylist text-align=left }
\
-- Wrap problematic expressions in DEAD-casts
{ .mylist text-align=left }
\
-- Elaborate source programs to target
{ .mylist text-align=left }


## 1st Phase (Trust) -- Clone

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#2(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```
```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#2 :: (ff, boolean) => boolean */
function negate#2(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```

## 1st Phase (Trust) -- Clone

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#2(flag, x) { ... }
```
```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#2 :: (ff, boolean) => boolean */
function negate#2(flag, x) { ... }
```

Overload resolution is based entirely on the *basic* type:

```javascript { border-width=0px font-family="Droid Sans Mono" }
var a = negate#1(1, 1);
var b = negate#2(0, true);
var c = negate#1(0, 1);
var d = negate#2(1, true);
```

## 1st Phase (Trust) -- Clone

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#2(flag, x) { ... }
```
```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#2 :: (ff, boolean) => boolean */
function negate#2(flag, x) { ... }
```

Replace with conventional products and projections:

```javascript { border-width=0px font-family="Droid Sans Mono" }
var negate = (negate#1, negate#2); 
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
var a = fst(negate)(1, 1);
var b = snd(negate)(0, true);
var c = fst(negate)(0, 1);
var d = snd(negate)(1, true);
```



## 1st Phase (Trust) -- Cast

Check each conjunct independently

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#2(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;  // TYPE ERROR
}
```


## 1st Phase (Trust) -- Cast

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#1(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !DEAD(x);  // ADD CAST
}
```

Add DEAD-cast for code that **should** be unreachable


## 2nd Phase (verify)

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#1(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !DEAD(x);
}
```

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#2 :: (ff, boolean) => boolean */
function negate#2(flag, x) { ... }
```

-- Performs standard refinement type-checking

-- Flow and Path sensitive 

```javascript { border-width=0px font-family="Droid Sans Mono" }
DEAD :: ∀ A, B . ({v: A | false}) => B
```


## 2nd Phase (Verify)

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate#1 :: (tt, number) => number */
function negate#1(flag, x) {
  if (flag) {
    return 0 - x;
  }
  else {
    return !DEAD(x);          // A
  }
}
```

Subtyping obligation at point A:

```{ border-width=0px font-family="Droid Sans Mono" }
Γ_A ˫ { v: number | v = x } ⊑ { v: number | false }
```

Embed into logic:

```{ border-width=0px font-family="Droid Sans Mono" }
(flag != 0 ∧ flag = 0) => ν = x => false
```




## Two-Phase Inference

```javascript { border-width=0px font-family="Droid Sans Mono" }
/*@ negate :: (number, number ) => number
           /\ (number, boolean) => boolean
 */
function negate(flag, x) {
  if (flag) 
    return 0 - x;
  else
    return !x;
}
```

Can we infer the refinements for `negate`? 



## Two-Phase Inference

0. Create a template and refine with a predicate variable:

``` { border-width=0px font-family="Droid Sans Mono" }
negate :: ({ v: number | k1 }, { v: number  | k2 }) => { v: number  | k3 }
       /\ ({ v: number | k4 }, { v: boolean | k5 }) => { v: boolean | k6 }
```

1. Trust Phase: like before

``` { border-width=0px font-family="Droid Sans Mono" }
negate#1 :: ({ v: number | k1 }, { v: number  | k2 }) => { v: number  | k3 }

negate#2 :: ... 
```


## Two-Phase Inference

2. Verify

```{ border-width=0px font-family="Droid Sans Mono" }
Γ_A ˫ { v: number | v = x } ⊑ { v: number | false }
```

```{ border-width=0px font-family="Droid Sans Mono" }
(k1[flag/v] ∧ flag = 0) => ν = x => false
```

3. Solve via Liquid Types:

```{ border-width=0px font-family="Droid Sans Mono" }
k1 := v = 0
```


## Formal Development
![Screenshot from 2015-04-30 08:29:12]

[Screenshot from 2015-04-30 08:29:12]: images/Screenshot-from-2015-04-30-08-29-12.png "Screenshot from 2015-04-30 08:29:12" { width=auto max-width=90% }

* Compile unrestricted intersections and unions

```{ border-width=0px font-family="Droid Sans Mono" }
% Int.+ ,, Real.+

val it : (int * int -> int) Λ (real * real -> real)
```