
GRAMMAR
=======

P   ::= Ci s                                  (Program)

C   ::= class A<Vi> extends A'<ti> { Md; Fd } (Class declarations)

N   ::=                                       (Named Types)
      | class A<Vi> extends A'<ti> { Md; Fd }   (class definitions)
      | interface I<Vi> extends Ii<ti>          (interface)
      | enum { fi }                             (enumeration)


I   ::=                                       (Interface)
      | interface I<Vi> { Md; Fd }              (interface definitions)


s   ::=                                       (Statements)
      | s; s                                    (sequence)
      | fun f(xi):sig { s }                     (function decalration)
      | var x[: t] = e                          (variable definition)
      | x := e                                  (assignment)
      | e.f := e                                (static field update)
      | e[e] := e                               (dynamic field update)
      | return [e]                              (return)
      | while(e) { s }                          (while loop)
      | if(e) { s1 } else { s2 }                (if-then-else)


e   ::=                                       (Expressions)
      | 1 | 2 | ...                             (numeric literal)
      | "a" | ...                               (string literal)
      | true | false                            (boolean literal)
      | op1 e                                   (unary operation) 
      | e op2 e                                 (binary operation)
      | { FD; MD }                              (object literal)
      | new C(ei)                               (class constructor)
      | [ei]                                    (array literal)
      | e.m(ei)                                 (method call)
      | f(ei)                                   (function call)
      | e.f                                     (static field access)
      | e1[e1]                                  (dynamic field access)
//Only in target language 
      | c e                                     (cast)


MD  ::=                                       (Callable class elements)
      | mod m(xi): sig { s }                    (method)
      | new (xi): sig { s }                     (constructor)


mod ::=                                       (Access modifier)
      | public 
      | private
      

FD  ::= f: e
      | F; F


-------------------------------------------------------------------------------

t   ::=        | { v: b | p }                            (refined type)


p   ::= ...                                   (Predicates)


b   ::=                                       (Base types)
      | number | string | boolean               (primitive)
      | null                                    (null)
      | V                                       (type variable)
      | N[ti]                                   (Type reference)
      | { Fd; Md }                              (object type)
      | [t]                                     (array type)
      | t1 \/ t2                                (union type)
      | top                                     (top)


sig ::=                                       (Type signature)
      | (xi:ti)=>t                              (arrow type)
      | ∀V.sig                                  (quantified type)    


ς   ::=                                       (Function specification)
      | sig                                     (function signature)
      | ς1 /\ ς2                                (signature intersection)


Fd  ::= { si: mi, ti }                        (Field declaration)


Md  ::= { mi: ςi }                            (Method declarations)


mi  ::=                                       (Field mutability modifier) 
      | m                                       (mutable)
      | i                                       (immutable)


c   ::=                                       (Casts)
      | .                                       (no cast - or upcast ?)
      | [ t \/ ts => ts ]                       (downcast)

-------------------------------------------------------------------------------

G   ::=                                       (Typing environment)


S   ::=                                       (Class environment)




NOTES:

  1. Function types are considered object types with a single field called
     "call".




Coercive subtyping
==================

 _______________________
|                       |
|   S |- t1 <: t2 ~> c  |         Subtyping jugdement
|_______________________|


    G |- t <: t ~> .                                  [S-Id]


    G |- t <: top ~> .                                [S-top]


    ------------------------------------------------- [S-Union-Up]
    G |- t <: t\/ti ~> .


    
    ------------------------------------------------- [S-Union-Down]
    G |- t\/ti <: ti ~> [ t\/ti => ti ]


    G |- ti' <: ti ~> .
    G |- t <: t' ~> .
    ------------------------------------------------- [S-Func]
    G |- (xi:ti)=>t <: (xi:ti')=>t' ~> .


    t1 <: t2 ~> .          t2 <: t1 ~> .
    ------------------------------------------------- [S-Array]
    G |- [t1] <: [t2]


    t1 <: t2 ~> .          t2 <: t1 ~> .
    ------------------------------------------------- [S-Interface]
    G |- I[t1] <: I[t2]

This needs to be invariant Unless we dig deep into I and prove that wherever the
As of I[A] appear, the mutability modifier is `im`.


    t <: t' ~> .
    ------------------------------------------------- [S-Field-D1]
    { f: _,t; Fd } <: { f: i,t'; Fd } ~> .


    t <: t' ~> .           t' <: t ~> .
    ------------------------------------------------- [S-Field-D2]
    { f: m,t; Fd } <: { f: m,t'; Fd } ~> .


    S(B) = class B extends B' { Md'; Fd' }
    {Md''; Fd''} <: B'
    ------------------------------------------------- [S-Field-D2]
    { Md; Fd } <: class B<> extends B' ~> .

    


 _____________________
|                     |
|   G; S |- s ~> s'   |         Raw Statement Typing Jugdement
|_____________________|


    G; S |-* e : t' ~> c
    ------------------------------------------------- [S-Field-DM]
    G; S |- var x: t = e ~> c



 _________________________
|                         |
|   G; S |- e : t ~> e'   |     Raw Expression Typing Jugdement
|_________________________|


NOTES: Union types are never inferred.




 ______________________
|                      |
|   G; S |- s ~> G'    |     Liquid Statement Typing Jugdement
|______________________|



 _____________________________
|                             |
|   G; S |- e : t ~> G', v    |     Liquid Statement Typing Jugdement
|_____________________________|



    t\p <: t\False
    ti\pi <: ti\qi
    ------------------------------------------------- [L-Cast]
    G; S |- [ t\p \/ ti\pi => ti\pi ] e ~> G', v 
